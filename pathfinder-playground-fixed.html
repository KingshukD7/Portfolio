<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pathfinding Playground</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;

        const GRID_SIZE = 25;
        const CELL_SIZE = 24;
        const ALGORITHMS = ['A*', 'Dijkstra', 'BFS', 'DFS'];

        const PathfinderPlayground = () => {
          const [grid, setGrid] = useState([]);
          const [start, setStart] = useState({ x: 5, y: 5 });
          const [end, setEnd] = useState({ x: 19, y: 19 });
          const [isRunning, setIsRunning] = useState(false);
          const [selectedAlgorithm, setSelectedAlgorithm] = useState('A*');
          const [drawMode, setDrawMode] = useState('wall');
          const [isDrawing, setIsDrawing] = useState(false);
          const [visitedCells, setVisitedCells] = useState(new Set());
          const [pathCells, setPathCells] = useState([]);
          const [stats, setStats] = useState({ visited: 0, pathLength: 0, time: 0 });

          useEffect(() => {
            const newGrid = Array(GRID_SIZE).fill(null).map(() => 
              Array(GRID_SIZE).fill(0)
            );
            setGrid(newGrid);
          }, []);

          const heuristic = (a, b) => {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
          };

          const getNeighbors = (node, currentGrid) => {
            const neighbors = [];
            const directions = [
              { x: 0, y: -1 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: -1, y: 0 }
            ];
            
            for (const dir of directions) {
              const newX = node.x + dir.x;
              const newY = node.y + dir.y;
              
              if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE && 
                  currentGrid[newY][newX] !== 1) {
                neighbors.push({ x: newX, y: newY });
              }
            }
            return neighbors;
          };

          const aStar = async (currentGrid, startPos, endPos) => {
            const startTime = performance.now();
            const openSet = [{ ...startPos, g: 0, h: heuristic(startPos, endPos), f: heuristic(startPos, endPos) }];
            const closedSet = new Set();
            const cameFrom = new Map();
            const gScore = new Map();
            gScore.set(`${startPos.x},${startPos.y}`, 0);

            while (openSet.length > 0) {
              openSet.sort((a, b) => a.f - b.f);
              const current = openSet.shift();
              const currentKey = `${current.x},${current.y}`;

              if (current.x === endPos.x && current.y === endPos.y) {
                const path = reconstructPath(cameFrom, current);
                setPathCells(path);
                setStats({
                  visited: closedSet.size,
                  pathLength: path.length,
                  time: ((performance.now() - startTime) / 1000).toFixed(2)
                });
                return;
              }

              closedSet.add(currentKey);
              setVisitedCells(new Set(closedSet));

              const neighbors = getNeighbors(current, currentGrid);
              for (const neighbor of neighbors) {
                const neighborKey = `${neighbor.x},${neighbor.y}`;
                if (closedSet.has(neighborKey)) continue;

                const tentativeG = gScore.get(currentKey) + 1;
                
                if (!gScore.has(neighborKey) || tentativeG < gScore.get(neighborKey)) {
                  cameFrom.set(neighborKey, current);
                  gScore.set(neighborKey, tentativeG);
                  
                  const h = heuristic(neighbor, endPos);
                  const f = tentativeG + h;
                  
                  if (!openSet.some(n => n.x === neighbor.x && n.y === neighbor.y)) {
                    openSet.push({ ...neighbor, g: tentativeG, h, f });
                  }
                }
              }

              await new Promise(resolve => setTimeout(resolve, 10));
            }
          };

          const dijkstra = async (currentGrid, startPos, endPos) => {
            const startTime = performance.now();
            const distances = new Map();
            const visited = new Set();
            const cameFrom = new Map();
            const queue = [{ ...startPos, dist: 0 }];
            
            distances.set(`${startPos.x},${startPos.y}`, 0);

            while (queue.length > 0) {
              queue.sort((a, b) => a.dist - b.dist);
              const current = queue.shift();
              const currentKey = `${current.x},${current.y}`;

              if (visited.has(currentKey)) continue;
              visited.add(currentKey);
              setVisitedCells(new Set(visited));

              if (current.x === endPos.x && current.y === endPos.y) {
                const path = reconstructPath(cameFrom, current);
                setPathCells(path);
                setStats({
                  visited: visited.size,
                  pathLength: path.length,
                  time: ((performance.now() - startTime) / 1000).toFixed(2)
                });
                return;
              }

              const neighbors = getNeighbors(current, currentGrid);
              for (const neighbor of neighbors) {
                const neighborKey = `${neighbor.x},${neighbor.y}`;
                const newDist = current.dist + 1;

                if (!distances.has(neighborKey) || newDist < distances.get(neighborKey)) {
                  distances.set(neighborKey, newDist);
                  cameFrom.set(neighborKey, current);
                  queue.push({ ...neighbor, dist: newDist });
                }
              }

              await new Promise(resolve => setTimeout(resolve, 10));
            }
          };

          const bfs = async (currentGrid, startPos, endPos) => {
            const startTime = performance.now();
            const queue = [startPos];
            const visited = new Set([`${startPos.x},${startPos.y}`]);
            const cameFrom = new Map();

            while (queue.length > 0) {
              const current = queue.shift();
              
              setVisitedCells(new Set(visited));

              if (current.x === endPos.x && current.y === endPos.y) {
                const path = reconstructPath(cameFrom, current);
                setPathCells(path);
                setStats({
                  visited: visited.size,
                  pathLength: path.length,
                  time: ((performance.now() - startTime) / 1000).toFixed(2)
                });
                return;
              }

              const neighbors = getNeighbors(current, currentGrid);
              for (const neighbor of neighbors) {
                const neighborKey = `${neighbor.x},${neighbor.y}`;
                if (!visited.has(neighborKey)) {
                  visited.add(neighborKey);
                  cameFrom.set(neighborKey, current);
                  queue.push(neighbor);
                }
              }

              await new Promise(resolve => setTimeout(resolve, 10));
            }
          };

          const dfs = async (currentGrid, startPos, endPos) => {
            const startTime = performance.now();
            const stack = [startPos];
            const visited = new Set();
            const cameFrom = new Map();

            while (stack.length > 0) {
              const current = stack.pop();
              const currentKey = `${current.x},${current.y}`;

              if (visited.has(currentKey)) continue;
              visited.add(currentKey);
              setVisitedCells(new Set(visited));

              if (current.x === endPos.x && current.y === endPos.y) {
                const path = reconstructPath(cameFrom, current);
                setPathCells(path);
                setStats({
                  visited: visited.size,
                  pathLength: path.length,
                  time: ((performance.now() - startTime) / 1000).toFixed(2)
                });
                return;
              }

              const neighbors = getNeighbors(current, currentGrid);
              for (const neighbor of neighbors) {
                const neighborKey = `${neighbor.x},${neighbor.y}`;
                if (!visited.has(neighborKey)) {
                  cameFrom.set(neighborKey, current);
                  stack.push(neighbor);
                }
              }

              await new Promise(resolve => setTimeout(resolve, 10));
            }
          };

          const reconstructPath = (cameFrom, current) => {
            const path = [];
            let curr = current;
            
            while (curr) {
              path.unshift(curr);
              const key = `${curr.x},${curr.y}`;
              curr = cameFrom.get(key);
            }
            
            return path;
          };

          const runAlgorithm = () => {
            setVisitedCells(new Set());
            setPathCells([]);
            setStats({ visited: 0, pathLength: 0, time: 0 });
            setIsRunning(true);

            // Capture current state
            const currentGrid = grid;
            const currentStart = start;
            const currentEnd = end;
            const currentAlgo = selectedAlgorithm;

            setTimeout(async () => {
              switch (currentAlgo) {
                case 'A*': await aStar(currentGrid, currentStart, currentEnd); break;
                case 'Dijkstra': await dijkstra(currentGrid, currentStart, currentEnd); break;
                case 'BFS': await bfs(currentGrid, currentStart, currentEnd); break;
                case 'DFS': await dfs(currentGrid, currentStart, currentEnd); break;
              }
              setIsRunning(false);
            }, 100);
          };

          const handleCellClick = (x, y) => {
            if (isRunning) return;

            const newGrid = [...grid.map(row => [...row])];
            
            if (drawMode === 'wall') {
              newGrid[y][x] = newGrid[y][x] === 1 ? 0 : 1;
            } else if (drawMode === 'start') {
              setStart({ x, y });
            } else if (drawMode === 'end') {
              setEnd({ x, y });
            }
            
            setGrid(newGrid);
          };

          const handleMouseDown = (x, y) => {
            setIsDrawing(true);
            handleCellClick(x, y);
          };

          const handleMouseEnter = (x, y) => {
            if (isDrawing && drawMode === 'wall') {
              handleCellClick(x, y);
            }
          };

          const handleMouseUp = () => {
            setIsDrawing(false);
          };

          const clearGrid = () => {
            setGrid(Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0)));
            setVisitedCells(new Set());
            setPathCells([]);
            setStats({ visited: 0, pathLength: 0, time: 0 });
          };

          const resetVisualization = () => {
            setVisitedCells(new Set());
            setPathCells([]);
            setStats({ visited: 0, pathLength: 0, time: 0 });
          };

          const getCellColor = (x, y) => {
            if (x === start.x && y === start.y) return 'bg-green-500';
            if (x === end.x && y === end.y) return 'bg-red-500';
            if (grid[y] && grid[y][x] === 1) return 'bg-gray-800';
            
            const isInPath = pathCells.some(cell => cell.x === x && cell.y === y);
            if (isInPath) return 'bg-yellow-400';
            
            if (visitedCells.has(`${x},${y}`)) return 'bg-blue-300';
            
            return 'bg-gray-100 hover:bg-gray-200';
          };

          return (
            <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 p-8">
              <div className="max-w-7xl mx-auto">
                <div className="text-center mb-8">
                  <h1 className="text-5xl font-bold text-white mb-3">Pathfinding Playground</h1>
                  <p className="text-gray-300 text-lg">Visualize and Compare Pathfinding Algorithms</p>
                </div>

                <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                  <div className="lg:col-span-1 space-y-4">
                    <div className="bg-white rounded-xl shadow-2xl p-6">
                      <h2 className="text-xl font-bold mb-4 text-gray-800">Algorithm</h2>
                      <div className="space-y-2">
                        {ALGORITHMS.map(algo => {
                          const getFullName = (abbr) => {
                            switch(abbr) {
                              case 'A*': return 'A* (A-Star)';
                              case 'Dijkstra': return 'Dijkstra';
                              case 'BFS': return 'BFS (Breadth-First Search)';
                              case 'DFS': return 'DFS (Depth-First Search)';
                              default: return abbr;
                            }
                          };
                          
                          return (
                            <button
                              key={algo}
                              onClick={() => setSelectedAlgorithm(algo)}
                              className={`w-full px-4 py-3 rounded-lg font-semibold transition-all ${
                                selectedAlgorithm === algo
                                  ? 'bg-purple-600 text-white shadow-lg'
                                  : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                              }`}
                            >
                              {getFullName(algo)}
                            </button>
                          );
                        })}
                      </div>
                    </div>

                    <div className="bg-white rounded-xl shadow-2xl p-6">
                      <h2 className="text-xl font-bold mb-4 text-gray-800">Draw Mode</h2>
                      <div className="space-y-2">
                        {[
                          { mode: 'wall', label: 'Wall', icon: 'ðŸ§±' },
                          { mode: 'start', label: 'Start Point', icon: 'ðŸŸ¢' },
                          { mode: 'end', label: 'End Point', icon: 'ðŸ”´' }
                        ].map(item => (
                          <button
                            key={item.mode}
                            onClick={() => setDrawMode(item.mode)}
                            className={`w-full px-4 py-3 rounded-lg font-semibold transition-all ${
                              drawMode === item.mode
                                ? 'bg-blue-600 text-white shadow-lg'
                                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                            }`}
                          >
                            {item.icon} {item.label}
                          </button>
                        ))}
                      </div>
                    </div>

                    <div className="bg-white rounded-xl shadow-2xl p-6">
                      <h2 className="text-xl font-bold mb-4 text-gray-800">Controls</h2>
                      <div className="space-y-2">
                        <button
                          onClick={runAlgorithm}
                          disabled={isRunning}
                          className="w-full px-4 py-3 bg-green-600 text-white rounded-lg font-semibold hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-all flex items-center justify-center gap-2"
                        >
                          â–¶ Visualize Path
                        </button>
                        <button
                          onClick={resetVisualization}
                          disabled={isRunning}
                          className="w-full px-4 py-3 bg-orange-600 text-white rounded-lg font-semibold hover:bg-orange-700 disabled:bg-gray-400 transition-all flex items-center justify-center gap-2"
                        >
                          â†» Reset
                        </button>
                        <button
                          onClick={clearGrid}
                          disabled={isRunning}
                          className="w-full px-4 py-3 bg-red-600 text-white rounded-lg font-semibold hover:bg-red-700 disabled:bg-gray-400 transition-all flex items-center justify-center gap-2"
                        >
                          ðŸ—‘ Clear Grid
                        </button>
                      </div>
                    </div>

                    <div className="bg-white rounded-xl shadow-2xl p-6">
                      <h2 className="text-xl font-bold mb-4 text-gray-800">Statistics</h2>
                      <div className="space-y-3">
                        <div className="flex justify-between items-center">
                          <span className="text-gray-600">Cells Visited:</span>
                          <span className="font-bold text-blue-600">{stats.visited}</span>
                        </div>
                        <div className="flex justify-between items-center">
                          <span className="text-gray-600">Path Length:</span>
                          <span className="font-bold text-yellow-600">{stats.pathLength}</span>
                        </div>
                        <div className="flex justify-between items-center">
                          <span className="text-gray-600">Time Elapsed:</span>
                          <span className="font-bold text-green-600">{stats.time}s</span>
                        </div>
                      </div>
                    </div>

                    <div className="bg-white rounded-xl shadow-2xl p-6">
                      <h2 className="text-xl font-bold mb-4 text-gray-800">Legend</h2>
                      <div className="space-y-2 text-sm">
                        <div className="flex items-center gap-2">
                          <div className="w-6 h-6 bg-green-500 rounded"></div>
                          <span>Start Point</span>
                        </div>
                        <div className="flex items-center gap-2">
                          <div className="w-6 h-6 bg-red-500 rounded"></div>
                          <span>End Point</span>
                        </div>
                        <div className="flex items-center gap-2">
                          <div className="w-6 h-6 bg-gray-800 rounded"></div>
                          <span>Wall</span>
                        </div>
                        <div className="flex items-center gap-2">
                          <div className="w-6 h-6 bg-blue-300 rounded"></div>
                          <span>Visited</span>
                        </div>
                        <div className="flex items-center gap-2">
                          <div className="w-6 h-6 bg-yellow-400 rounded"></div>
                          <span>Final Path</span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="lg:col-span-2">
                    <div className="bg-white rounded-xl shadow-2xl p-8">
                      <div 
                        className="inline-block border-4 border-gray-300 rounded-lg overflow-hidden"
                        onMouseUp={handleMouseUp}
                        onMouseLeave={handleMouseUp}
                      >
                        {grid.map((row, y) => (
                          <div key={y} className="flex">
                            {row.map((cell, x) => (
                              <div
                                key={`${x}-${y}`}
                                onMouseDown={() => handleMouseDown(x, y)}
                                onMouseEnter={() => handleMouseEnter(x, y)}
                                className={`${getCellColor(x, y)} transition-all cursor-pointer border border-gray-300`}
                                style={{
                                  width: `${CELL_SIZE}px`,
                                  height: `${CELL_SIZE}px`
                                }}
                              />
                            ))}
                          </div>
                        ))}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          );
        };

        ReactDOM.render(<PathfinderPlayground />, document.getElementById('root'));
    </script>
</body>
</html>
